# 基本概念

1、Java不仅是编程语言，还是一个开发平台，Sun公司根据Java应用领域的不同将Java分成三个平台：Java SE、Java EE、Java ME。

2、.java文件   ---通过编译--->   .class文件   ---通过解释器--->   计算机

3、JDK包含JRE，JRE包含JVM

4、Java中注释的语法有三种：
- ①单行注释(//)
- ②多行注释(/*  */)
- ③文档注释(/**  */)，文档注释是指这种注释内容能够生成API帮助文档，JDK中javadoc命令能够提取这些注释信息并生成html文件。

5、Java语言的数据类型分为基本数据类型和引用数据类型。

6、基本数据类型表示简单的数据，基本数据类型分为四大类共八种数据类型：
- 整数类型：byte、short、int、long
- 浮点类型：float、double
- 字符型：char
- 布尔类型：boolean
其中整数类型、浮点类型和字符类型都属于数值类型，它们之间可以相互转换。

7、数值类型相互转换：转换有两个方向：自动类型转换和强制类型转换。小范围数据类型可以自动转换为大范围数据类型，但是大范围数据类型需要强制类型转换为小范围数据类型。强制类型转换有可能会导致数据精度丢失。

8、在Java中除了八种基本数据类型外，其它数据类型全部都是引用(reference)数据类型，引用数据类型变量中保存的是指向对象的内存地址。

9、Java中的运算符（也称操作符）在风格和功能上都与C和C++极为相似，在任何一种编程语言中，运算符都具有优先级和结核性两种属性。

10、在任何一种编程语言中，都有三种流程控制：顺序、选择、循环。

11、Java中数组具有如下三个基本特性：
- ①一致性：数组中只能保存相同数据类型的元素
- ②有序性：数组中的元素是有序的，通过下标访问
- ③不可变性：数组一旦初始化，则长度（数组中元素的个数）不可变

12、Java中数组本身是引用数据类型，它的长度属性是length

13、数组初始化可以分为静态初始化和动态初始化。静态初始化就是将数组的元素放到大括号({})中，元素之间用逗号(,)分隔；动态初始化使用new运算符分配指定长度的内存空间，语法如下：new 元素数据类型[数组长度]。

14、由字符组成的一串字符序列称为字符串。

15、JavaSE提供了三个字符串类：String、StringBuffer、StringBuilder。String是不可变字符串，StringBuffer和StringBuilder是可变字符串。

16、可变字符串和不可变字符串，它们的区别在于当字符串进行修改操作时，不可变字符串会创建新的字符串，而可变字符串不会创建新对象。
# 面向对象
## 面向对象基础
1、面向对象思想有三个基本特性：封装性、继承性和多态性。

2、包本质上是命名空间，在Java中使用package语句定义包，package语句应该放在源文件的第一行，在每个源文件中只能有一个包定义语句。Java编译器把包对应于文件系统的目录管理，不仅是源文件，编译之后的字节码文件也是采用文件系统的目录管理的。

3、为了能够使用一个包中类型（类、接口、枚举、注解等），需要在Java程序中明确引入该类型，使用import语句实现引入，import语句应位于package语句之后，所有类定义之前，可以有0～n条import语句，当前源文件与要使用的类型（类、接口、枚举、注解等）在同一个包中，可以不用引入，使用java.lang包中的类型，不需要显示使用import语句引入，它是由解释器自动引入的。

4、方法重载是指在一个类中或类继承关系中定义多个方法名相同，但参数个数或类型不同的方法，另外返回值类型不能用来区分方法重载。

5、Java面向对象的封装性是通过对成员变量和方法进行访问控制实现的，访问控制分为四个等级：私有private、默认、保护protected、公有public。

6、static修饰的成员变量是静态变量，static修饰的方法是静态方法，相反没有static修饰的成员变量和成员方法是实例变量和实例方法。实例变量和实例方法是属于实例的，静态变量和静态方法是属于类的。

7、在Java中代码块有三种类型：
- 局部代码块：方法定义
- 静态代码块： static{} 执行优先级高于非静态的初始化块，它会在类初始化的时候执行一次，执行完成便销毁，它仅能初始化类变量，即static修饰的数据成员。
- 构造代码块：{} 执行的时候如果有静态初始化块，先执行静态初始化块再执行非静态初始化块，在每个对象生成时都会被执行一次，它可以初始化类的实例变量。非静态初始化块会在构造函数执行时，在构造函数主体代码执
行之前被运行。

8、一个对象的生命周期包括三个阶段：创建、使用和销毁。创建对象包括两个步骤：声明和实例化，声明对象和声明普通变量没有区别，格式：type objectName;实例化过程分为两个阶段：为对象分配内存空间（使用new关键字）和初始化对象（调用构造方法）。对象不再使用时应该销毁，Java语言对象是由垃圾回收器（garbage collection）收集然后释放，程序员不用关系释放的细节。

## 继承与多态

1、一个子类只能继承一个父类，这称为单继承。一个子类可以继承多个父类，这称为多继承。在Java中类的继承只能是单继承，也就是说在Java中一个类只能继承一个父类，但是可以实现多个接口。另外接口继承是多继承。

2、当子类实例化时，不仅需要初始化子类成员变量，也需要初始化父类成员变量，初始化父类成员变量需要调用父类构造方法，子类使用super关键字调用父类构造方法，如果子类没有显示地调用super，编译器会试图调用父类的默认构造方法（无参构造方法）。

3、使用this调用其它构造方法时，this语句一定时该构造方法的第一条语句，同样地，super语句也必须位于子类构造方法的第一行。

4、子类成员变量与父类一样，会屏蔽父类中的成员变量，称为成员变量隐藏，但子类可以使用super关键字访问到父类中被隐藏的变量。

5、如果子类方法完全与父类方法相同，即相同的方法名、相同的参数列表和相同的返回值，只是方法体不同，这称为子类覆盖（override）父类方法，但子类可以使用super关键字访问到父类中被覆盖的方法。

6、发生多态要有三个前提条件：
- 继承：多态发生在子类和父类之间
- 覆盖：子类覆盖了父类的方法
- 声明的变量类型是父类类型，但实例则指向子类实例。

7、多态发生时，Java虚拟机运行时根据引用变量指向的实例调用它的方法，而不是根据引用变量的类型调用。

8、基本类型之间的转换只能在数值类型之间进行，这里所说的数值类型包括整型、字符型和浮点型。引用类型之间的转换只能在具有继承关系的两个类型之间进行，如果是两个没有任何继承关系的类型，则无法进行类型转换，否则编译时即会出现错误。

9、与数值类型之间转换类似，引用类型之间转换也有两个方向：
- 将父类引用类型变量转换为子类类型，这种转换称为向下转型；
- 将子类引用类型变量转换为父类类型，这种转换称为向上转型；

向下转型需要强制转换，而向上转型是自动的。如果试图把一个父类实例转换成子类类型，则这个对象必须实际上是子类类型才行（即编译时类型为父类类型，而运行时类型是子类类型），否则将在运行时引发ClassCastException异常。

## 抽象类与接口

1、在Java中抽象类和抽象方法的修饰符是abstract。如果一个方法被声明为抽象的，那么这个类也必须声明为抽象的，而一个抽象类中可以有0～n个抽象方法，以及0～n个具体方法。

2、比抽象类更加抽象的是接口，在接口中所有的方法都是抽象的，在Java中接口的声明使用关键字interface。Java8之后接口中新增了默认方法，因为“接口中所有的方法都是抽象的”，这个说法在Java8之后是有待商榷的。

3、Java中一个类只能extends一个父类，但是可以implements多个接口；一个接口则可以同时extends多个接口，但不能implements任何接口。因为类是单继承的，接口是支持多继承的。

4、抽象类与接口的区别：
- 接口支持多继承，而抽象类（包括具体类）只能继承一个父类；
- 接口中不能有实例成员变量，接口中所声明的成员变量全部是静态常量，即使不加public static final修饰也是静态常量，而抽象类与普通类一样，各种形式的成员变量都可以声明。
- 接口中没有包含构造方法，由于没有实例成员变量，也就不需要构造方法，抽象类中可以有实例成员变量，也需要构造方法；
- 抽象类中可以声明抽象方法和具体方法，Java8之前接口中只有抽象方法，而Java8之后接口中也可以声明具体方法，具体方法通过声明默认方法和静态方法实现。

## 枚举类

1、Java枚举类型本质上继承java.lang.Enum类，是引用数据类型，因此也称为枚举类，枚举用来管理一组相关常量的集合。

2、Java5之后可以使用枚举类型，Java中枚举类型的作用已经不仅仅是定义一组常量提高程序的可读性，还具有如下特性：
- Java枚举类型是一种类，是引用类型，具有面向对象特性可以添加方法和成员变量等；
- Java枚举类型父类是java.lang.Enum，不需要显示声明；
- Java枚举类型可以实现接口，与类实现接口类似；
- Java枚举类型不能被继承，不存在子类。

3、枚举类中的构造方法只能是私有的，构造方法可以省略private关键字，但它仍然是私有的构造方法，这也说明了枚举类不允许在外部创建对象

4、当需要一个有限集合，而集合中的数据为特定值时可以使用枚举类型。

5、枚举类型本质上是一个类，其中的每一个枚举值都是该类的一个对象。

## Java常用类
1、java.lang.Object类是Java所有类的根类，Java所有类都直接或间接继承自Object类，它是所有类的祖先。

2、在Java中八种基本数据类型不属于类，不具备对象特征，没有成员变量和方法，不方便进行面向对象的操作，因此Java提供包装类来将基本数据类型包装成类，每个Java基本数据类型在java.lang包中都有一个相对应的包装类，每个包装类对象封装一个基本数据类型值。

3、包装类都是final的，不能被继承。包装类都是不可变类，类似于String。

4、包装类还可以分成三种不同类型：数值包装类（Byte、Short、Integer、Long、Float、Double）、Character、Boolean。

5、自动装箱/拆箱：拆箱能够将包装类对象自动转换为基本数据类型的值；装箱能够自动地将基本数据类型的值自动转换为包装类对象。


## 内部类
1、在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：局部内部类、成员内部类、静态内部类、匿名内部类。

# Java进阶
## 异常处理
1、JDK中定义了一套完整的异常机制，所有异常都是Throwble的子类（Throwable有两个直接子类：Error和Exception），分为Error（致命异常）和Exception（非致命异常）。Error是一种非常特殊的异常类型，它的出现标志着系统发生了不可控的错误，针对此类错误，程序无法处理，只能人工介入。Exception又分为checked异常（受检异常）和unchecked异常（非受检异常）。checked异常是需要在代码中显示处理的异常，否则编译错误。unchecked异常都继承自RuntimeException，可以捕捉也可以不捕捉。

2、Error是程序无法恢复的严重错误，程序员根本无能为力，只能让程序终止；Exception是程序可以恢复的异常，它是程序员所能掌控的。

3、捕捉异常是通过try-catch语句实现的。每个try代码块可以伴随一个或多个catch代码块，用于处理try代码块中可能发生的多种异常。

4、当捕获的多个异常类之间存在父子关系时，捕获异常顺序与catch代码块的顺序有关。一般先捕获子类，再捕获父类，否则子类捕获不到。

5、Java提供的try-catch语句嵌套可以任意嵌套。

6、有时在try-catch语句中会占用一些非Java资源，如打开文件、网络连接、打开数据库连接和使用数据库结果集等，这些资源并非Java资源，不能通过JVM的垃圾收集器回收，需要程序员释放。为了确保这些资源能够被释放，可以使用finally代码块或Java7之后提供的自动资源管理技术（automatic resource management）。

7、自动资源管理是在try语句上的扩展，在try语句后面添加一对小括号“()”,其中是声明或初始化资源语句，可以有多条语句，语句之间用分号(;)分隔。

8、所有可以自动管理的资源需要实现AutoCloseable接口。

9、一个方法中如果能够处理异常，则需要捕获并处理。但是若方法没有能力处理该异常，捕获它没有任何意义，此时需要在方法后面声明抛出该异常，通知上层调用者该方法有可能发生异常，方法后面声明抛出使用throws关键字。

10、throws用于方法后声明抛出异常，而throw关键字用来人工引发异常。

## collection
1、collection本质上是基于某种数据结构的数据容器。常见的数据结构有数组（Array）、集合（Set）、队列(Queue)、链表（Linkedlist）、树（Tree）、堆（Heap）、栈（Stack）和映射（Map）等。

2、在Java中任何collection中存放的都是对象，即引用数据类型，基本数据类型不能放到collection中。

## 泛型
1、Java5之后提供泛型（generics）支持，使用泛型可以最大限度地重用代码、保护类型的安全以及提高性能。

2、泛型对Java影响最大的就是collection。

3、根据自己的需要也可以自定义泛型类、泛型接口和带有泛型参数的方法。

4、泛型用来规定一个类、接口或方法所能接受的数据类型，就像在声明方法时指定参数一样，我们在声明一个类、接口或方法时，也可以指定其“类型参数”，也就是泛型，所以泛型的本质就是参数化类型，泛型有以下优点：
- 重用代码；
- 提高安全性：将运行期的错误转换到编译期，如果我们在对一个对象所赋的值不符合其泛型的规定，就会编译报错
- 避免强转：比如我们在使用list时，如果不使用泛型当从list中取出元素时，其类型会是默认的Object，我们必须将其向下转型才能使用。

## 反射
1、反射（reflection）是程序的自我分析能力。

2、Java反射机制API主要是java.lang.Class类和java.lang.reflect包。

3、java.lang.Class类是实现反射的关键所在，Class类的一个实例表示Java的一种数据类型，包括类、接口、枚举、注解、数组、基本数据类型和void。Class没有公有的构造方法，Class类实例由JVM在类加载时自动创建。

4、在程序代码中获得Class实例可以通过以下三种方法：
- 通过类型class静态变量；
- 通过对象的getClass方法；
- 通过Class类的forName方法

5、Java反射机制提供了另外一种创建对象的方法。

## 注解

1、注解本质是一种接口，它是java.lang.annotation.Annotation接口的子接口，是引用数据类型。

2、到Java8为止，Java SE提供了11种内置注解，其中有5种是基本注解，它们来自于java.lang包；有6种是元注解，它们来自于java.lang.annotation包：
- 基本注解：@Override、@Deprecated、@SuppresWarnings、@SafeVarargs、@FunctionalInterface
- 元注解：@Documented、@Target、@Retention、@Inherited、@Repeatable、@Native

3、读取注解信息需要使用反射相关API。

4、注解使用上分为三个步骤：
- 注解定义；
- 注解使用；
- 注解提取。

5、注解是对程序元素（类、方法、成员变量等）的一种说明，或者说是对程序元素的一种描述，类似于xml。注解不影响程序代码的执行，无论增加删除注解，代码都始终如一地执行。如果希望让程序中的注解起某种作用，只有通过注解提取，对详解中的信息进行访问和处理。

## 数据库编程
1、Java中数据库编程是通过JDBC实现的，使用JDBC技术涉及三种不同的角色：
- java官方：提供JDBC接口；
- 数据库厂商：提供具体的实现类；
- 开发人员。

2、在编程实现数据库连接时，JVM必须先加载特定厂商提供的数据库驱动程序。使用Class.forName()方法实现驱动程序加载过程。

3、JDBC编程步骤：
- 1）加载驱动程序；
- 2）建立数据库连接，得到Connection对象；
- 3）创建Statement对象（根据Connection对象的方法）；
- 4）运行SQL语句（根据Statement对象的方法）；
- 5）处理结果（SELECT返回的结果是ResultSet对象，insert、update、delete返回的结果是影响到的记录数）；
- 6）释放资源，关闭顺序与声明顺序相反。

